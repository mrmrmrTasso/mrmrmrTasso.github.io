<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>背包问题</title>
      <link href="/2023/06/19/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/06/19/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>最近刷力扣每日一题的时候，又碰到了动态规划的题目，而且它这种题型是典型的背包问题。题目如下（力扣1262）：</p><p>给你一个整数数组 <code>nums</code>，请你找出并返回能被三整除的元素最大和。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,6,5,1,8]</span><br><span class="line">输出：18</span><br><span class="line">解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4]</span><br><span class="line">输出：0</span><br><span class="line">解释：4 不能被 3 整除，所以无法选出数字，返回 0。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,4]</span><br><span class="line">输出：12</span><br><span class="line">解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 4 * 10^4</code></li><li><code>1 &lt;= nums[i] &lt;= 10^4</code></li></ul><p>为什么说它是背包问题呢？首先，它和01背包一样，都给定了一个限定条件，只不过01背包是容量限制，而这道题是余数限制。还有，都是从集合中进行选择，对于第i个元素，都有选和不选两种选择，最终的目的都是使得target最优。</p><p>本题最合适的方法便是动态规划，下面是分析的过程：</p><h3 id="子问题分析"><a href="#子问题分析" class="headerlink" title="子问题分析"></a>子问题分析</h3><p><img src="img/blog/image-20230619185049732.png" alt="image-20230619185049732"></p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>定义<code>dp[i][j]</code>为<code>nums[0, i]</code>（双闭区间）内余数和为j的最大值，那么状态转移方程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][loc] = Math.max(dp[i][loc], num);</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> dp[i-<span class="number">1</span>][j]+nums[i];</span><br><span class="line"><span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> num % <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>完整的java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumDivThree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]%<span class="number">3</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.arraycopy(dp[i-<span class="number">1</span>],<span class="number">0</span>,dp[i],<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> dp[i-<span class="number">1</span>][j]+nums[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> num % <span class="number">3</span>;</span><br><span class="line">                dp[i][loc] = Math.max(dp[i][loc], num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于第i层的结果依赖于第i-1层，因此我们可以将矩阵进行纵向压缩，优化后的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumDivThree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>], dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        pre[nums[<span class="number">0</span>]%<span class="number">3</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.arraycopy(pre,<span class="number">0</span>,dp,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> pre[j]+nums[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> num % <span class="number">3</span>;</span><br><span class="line">                dp[loc] = Math.max(dp[loc], num);</span><br><span class="line">            &#125;</span><br><span class="line">            System.arraycopy(dp,<span class="number">0</span>,pre,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="和01背包的相似之处"><a href="#和01背包的相似之处" class="headerlink" title="和01背包的相似之处"></a>和01背包的相似之处</h3><p>我们知道，01背包的dp矩阵规模为<code>dp[n][c+1]</code>，压缩之后为<code>dp[c+1]</code>，而此题的dp矩阵规模为<code>dp[n][3]</code>，压缩之后为<code>dp[3]</code>。</p><p>而c和3，一个是指容量，一个是指余数，两个都是限定条件。</p><p>再看递推方程，两个都是根据前面一个子问题的情况求解当前子问题。</p><p>其实，这样类似的题还有很多，下面是力扣常见的背包问题：</p><ul><li>力扣416 分割等和子集 01背包是否问题</li><li>力扣322 零钱兑换 完全背包最值问题</li><li>力扣518 零钱兑换2 完全背包组合问题</li><li>力扣494 目标和 01背包组合问题</li><li>力扣139 单词拆分 完全背包排列问题</li><li>力扣279 完全平方数 完全背包组合问题</li><li>力扣377 组合总和4 完全背包排列问题</li></ul><h2 id="背包问题描述"><a href="#背包问题描述" class="headerlink" title="背包问题描述"></a>背包问题描述</h2><p>背包问题可以描述为——从物品集合中选取物品至背包，在拿放过程中可能涉及到的求解任务有：</p><ol><li><strong>背包可以容纳物品的最大价值（背包最值）</strong></li><li><strong>背包容纳指定价值物品的组合数（背包组合）</strong></li><li><strong>背包能否容纳指定价值的物品（背包是否）</strong></li></ol><p>背包问题主要分为01背包与完全背包。</p><p><strong>01背包是指物品集中每个物品只能拿取一次，完全背包是指物品集中每个物品无限制次数拿取。</strong></p><h2 id="第一题：分割等和子集（力扣416）（01背包是否问题）"><a href="#第一题：分割等和子集（力扣416）（01背包是否问题）" class="headerlink" title="第一题：分割等和子集（力扣416）（01背包是否问题）"></a>第一题：分割等和子集（力扣416）（01背包是否问题）</h2><p>题目描述见力扣，该题目可以转化为——从给定数组（物品集）中拿取数字，使背包物品价值（求和）恰好等于数组和的一半。<strong>所以这是一个01背包是否问题。</strong></p><p>首先判断数组和是否为偶数，不是偶数显然无法分割等和子集。接着求数组中的最大值，如果最大值大于数组和的一半，显然也无法分割等和子集。</p><p>这些判断条件是必要的。如果不经过判断直接使用dp背包有的case会出错。比如数组和为奇数的数组，其除以2向下取整后得到的目标target是错误的（真正的目标target是浮点数）；比如说如果存在数组中最大值大于数组和一半的情况，那后续dp数组初始化会报错，因为最大值比target大，初始化时一定会数组越界。</p><p>接下来就是构建背包dp数组，是本题的重头戏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][target+<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><code>dp[i][j]</code>的意义是：对于输入数组nums，在给定nums[0,i]区间（双闭区间）内，能否找到数字组合使其总和为j。显而易见，数组所有值先设为False。</p><p>然后是二维数组的初始化。</p><p>一般来说dp数组最重要的是<strong>递推公式的构建。</strong>这就要求数组的第一行与第一列初始值必须是正确的，这样才能保证依赖这些初始值进行的递推计算是正确的。</p><p>该题的初始化操作为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target为的位置全部初始化为true</span></span><br><span class="line"><span class="comment">// dp[i][nums[i]]的位置也一定为true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dp[i][nums[i]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递推公式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=target; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">            <span class="comment">// 两种情况有一种为true的话便成立</span></span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j]|dp[i-<span class="number">1</span>][j-nums[i]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Arrays.stream(nums).max().getAsInt();</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (max &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][target+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            dp[i][nums[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=target; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    <span class="comment">// 两种情况有一种为true的话便成立</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j]|dp[i-<span class="number">1</span>][j-nums[i]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码用到了一个二维矩阵，空间复杂度比较大，我们可以继续优化。</p><p>观察递推代码可以发现，递推代码中<code>dp[i-1][j]</code>、<code>dp[i-1][j-nums[i]]</code>被频繁使用，也就是说，当前行的递推计算仅取决于上一行的这两个位置的数，其他数字不要也可以，但是上一行却占了一整行的空间。</p><p><img src="/img/blog/image-20230619130851003.png" alt="image-20230619130851003"></p><p>我们可以把<code>dp[n][target+1]</code>给压缩成<code>dp[target+1]</code>（可以理解成纵向压扁），<strong>但需要从后往前更新</strong>。</p><p>因为只有倒序循环，<strong>计算<code>dp[i][j]</code>的时候<code>dp[i-1][j-nums[i]]</code>才没有被覆盖</strong>（空间优化后，只剩一行了），上述代码里的<code>dp[j-t]</code>才是正确的<code>dp[i-1][j-nums[i]]</code>（因为<code>dp[i-1][j-nums[i]]</code>一定在<code>dp[i-1</code>][j]的前面）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Arrays.stream(nums).max().getAsInt();</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (max &gt; target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[target+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 第一件物品选与不选</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        dp[nums[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    <span class="comment">// 两种情况有一种为true的话便成立</span></span><br><span class="line">                    dp[j] = dp[j]|dp[j-nums[i]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// else就可以省略掉了</span></span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化前：</p><p><img src="/img/blog/image-20230619134152367.png" alt="image-20230619134152367"></p><p>优化后：</p><p><img src="/img/blog/image-20230619134216565.png" alt="image-20230619134216565"></p><h2 id="第二题：目标和（力扣494）（01背包组合问题）"><a href="#第二题：目标和（力扣494）（01背包组合问题）" class="headerlink" title="第二题：目标和（力扣494）（01背包组合问题）"></a>第二题：目标和（力扣494）（01背包组合问题）</h2><h3 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h3><p>遇到这种01背包组合问题，最简单的方法就是暴力搜，Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        dfs(nums, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> i, <span class="type">int</span> cur)</span> &#123;</span><br><span class="line">        <span class="comment">// 只有i为nums.length的时候才返回，因为每个元素都需要考虑</span></span><br><span class="line">        <span class="keyword">if</span> (i == nums.length) &#123; </span><br><span class="line">            ans += cur == target ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nums, target, i + <span class="number">1</span>, cur + nums[i]);</span><br><span class="line">        dfs(nums, target, i + <span class="number">1</span>, cur - nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><p>不难发现，在 DFS 的函数签名中只有「数值下标 i」和「当前结算结果 cur」为可变参数，考虑将其作为记忆化容器的两个维度，返回值作为记忆化容器的记录值。</p><p>由于 cur 存在负权值，为了方便，我们这里不设计成静态数组，而是使用「哈希表」进行记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> i, <span class="type">int</span> cur)</span> &#123;</span><br><span class="line">        <span class="comment">// 二元组转化成字符串进行存储</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> i + <span class="string">&quot;_&quot;</span> + cur;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) <span class="keyword">return</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">            cache.put(key, cur == target ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> cache.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(nums, target, i + <span class="number">1</span>, cur + nums[i]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> dfs(nums, target, i + <span class="number">1</span>, cur - nums[i]);</span><br><span class="line">        cache.put(key, left + right);</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>这道题用动态规划不太好做其实</p><p>在【416.分割等和子集】这道题中，要求的输出结果就是boolean值，因此我们定义的dp数组只需要记录T/F即可，但是这道题要求返回结果是方法数，那么我们dp数组需要记录的数据就是具体的方法数。</p><p>搞清楚需要输出的结果后，就可以来想办法画一个表格，也就是定义dp数组的含义。根据背包问题的经验，可以将<code>dp[i][j]</code>定义为从数组nums中 0 - i 的元素进行加减可以得到 j 的方法数量。</p><p>搞清楚状态以后，我们就可以根据状态去考虑如何根据子问题的转移从而得到整体的解。这道题的关键不是nums[i]的选与不选，而是nums[i]是加还是减，那么我们就可以将方程定义为：</p><pre><code>dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]</code></pre><p>可以理解为nums[i]这个元素我可以执行加，还可以执行减，那么我<code>dp[i][j]</code>的结果值就是加/减之后对应位置的和。</p><p>初始状态：<code>dp[0][nums[0]] = dp[0][-nums[0]] = 1</code>，这里有种特殊情况，就是如果nums[0]=0，那么<code>dp[0][0] = 2</code>，意思是有加和减两种情况。</p><p>然后，我们就可以进行愉快的递推了，最终<code>dp[n-1][target]</code>就是所求的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绝对值范围超过了sum的绝对值范围则无法得到</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(target) &gt; Math.abs(sum)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// - 0 +</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> sum * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len][t];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][sum] = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][sum + nums[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">            dp[<span class="number">0</span>][sum - nums[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">                <span class="comment">// 边界</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> (j - nums[i]) &gt;= <span class="number">0</span> ? j - nums[i] : <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (j + nums[i]) &lt; t ? j + nums[i] : <span class="number">0</span>;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][l] + dp[i - <span class="number">1</span>][r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][sum + target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="01背包最值问题"><a href="#01背包最值问题" class="headerlink" title="01背包最值问题"></a>01背包最值问题</h2><p>这一类问题是01背包最经典的问题，有时间再更。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>统计回文子串的数量</title>
      <link href="/2023/06/18/%E7%BB%9F%E8%AE%A1%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E7%9A%84%E6%95%B0%E9%87%8F/"/>
      <url>/2023/06/18/%E7%BB%9F%E8%AE%A1%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E7%9A%84%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目来源：力扣 647</p><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p><p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>如果一上来用暴力写的话，必定超时，时间复杂度为O($n^3$)。超时的原因很简单，因为对于每一个子串我们都进行了遍历，这样会造成很多的重复计算。因此，我们需要考虑利用某些子串的判断结果来简化算法的复杂度。这里介绍动态规划和中心扩散两种方法。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动规的解题步骤：</p><h4 id="1-确定dp数组（dp-table）以及下标的含义"><a href="#1-确定dp数组（dp-table）以及下标的含义" class="headerlink" title="1.确定dp数组（dp table）以及下标的含义"></a>1.确定dp数组（dp table）以及下标的含义</h4><p>布尔类型的<code>dp[i][j]</code>：表示区间范围<code>[i,j]</code> （注意是<strong>左闭右闭</strong>）的子串是否是回文子串，如果是<code>dp[i][j]</code>为true，否则为false。</p><h4 id="2-确定递推公式"><a href="#2-确定递推公式" class="headerlink" title="2.确定递推公式"></a>2.确定递推公式</h4><p>在确定递推公式时，就要分析如下几种情况。</p><p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p><ul><li>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</li><li>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况<ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看<code>dp[i + 1][j - 1]</code>是否为true。</li></ul></li></ul><p>以上三种情况分析完了，那么递归公式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">        result++;</span><br><span class="line">        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">        result++;</span><br><span class="line">        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>result就是统计回文子串的数量。</p><p>注意这里我没有列出当s[i]与s[j]不相等的时候，因为在下面dp[i][j]初始化的时候，就初始为false。</p><p>dp数组如何初始化</p><p><code>dp[i][j]</code>可以初始化为true么？ 当然不行，怎能刚开始就全都匹配上了。</p><p>所以<code>dp[i][j]</code>初始化为false。</p><p>确定遍历顺序</p><p>遍历顺序可有有点讲究了。</p><p>首先从递推公式中可以看出，情况三是根据<code>dp[i + 1][j - 1]</code>是否为true，在对dp[i][j]进行赋值true的。</p><p><code>dp[i + 1][j - 1]</code>在 <code>dp[i][j]</code>的左下角，如图：</p><p><img src="/img/blog/dp矩阵-回文子串.png" alt="dp矩阵"><br>如果这矩阵是从上到下，从左到右遍历，那么会用到没有计算过的<code>dp[i + 1][j - 1]</code>，也就是根据不确定是不是回文的区间[i+1,j-1]，来判断了[i,j]是不是回文，那结果一定是不对的。</p><p>所以一定要从下到上，从左到右遍历，这样保证<code>dp[i + 1</code>][j - 1]都是经过计算的。</p><p>有的代码实现是优先遍历列，然后遍历行，其实也是一个道理，都是为了保证<code>dp[i + 1</code>][j - 1]都是经过计算的。</p><p>C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j-i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        result++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i+<span class="number">1</span>][j<span class="number">-1</span>]) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        result++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="dp矩阵的压缩"><a href="#dp矩阵的压缩" class="headerlink" title="dp矩阵的压缩"></a>dp矩阵的压缩</h3><p>可以看到，上面这种方法用到的dp矩阵是二维的，空间复杂度比较高。有没有一种办法来降低空间复杂度呢？答案是可以的。使用压缩矩阵的思路。</p><p>压缩二维矩阵的适用条件：当这一层（列）的结果仅依赖于上一层（列）时，那么可以在这一层（列）进行原地更新。</p><p>观察上面这个状态转移方程，我们知道，矩阵是从下网上遍历的，第i层的结果依赖于第i+1层，因此我们可以将矩阵进行纵向压缩。</p><p>遍历的顺序：必须是从下往上，从右往左。为什么必须是从右往左，而上面就可以从左往右呢？那是因为压缩后dp[j]依赖原来的dp[j-1]，如果从左往右的话，原来的dp[j-1]就会被新的给覆盖掉。</p><p>C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n<span class="number">-1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j-i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[j] = <span class="literal">true</span>;</span><br><span class="line">                        result++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                        dp[j] = <span class="literal">true</span>;</span><br><span class="line">                        result++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[j] = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="中心扩散"><a href="#中心扩散" class="headerlink" title="中心扩散"></a>中心扩散</h2><p>首先确定回文串，就是找中心然后想两边扩散看是不是对称的就可以了。</p><p>在遍历中心点的时候，要注意中心点有两种情况。</p><p>一个元素可以作为中心点，两个元素也可以作为中心点。</p><p>对于三个元素，可以由一个元素左右添加元素得到，四个元素则可以由两个元素左右添加元素得到，所以我们在计算的时候，要注意一个元素为中心点和两个元素为中心点的情况。</p><p>C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            result += <span class="built_in">extend</span>(s, i, i, s.<span class="built_in">size</span>()); <span class="comment">// 以i为中心</span></span><br><span class="line">            result += <span class="built_in">extend</span>(s, i, i + <span class="number">1</span>, s.<span class="built_in">size</span>()); <span class="comment">// 以i和i+1为中心</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上两种方法对应的时间复杂度都是$O(n^2)$。</p><p>两种方法参考了代码随想录大佬的思路，链接：<a href="https://leetcode.cn/problems/palindromic-substrings/solutions/917242/dai-ma-sui-xiang-lu-dai-ni-xue-tou-dpzi-vidge/。">https://leetcode.cn/problems/palindromic-substrings/solutions/917242/dai-ma-sui-xiang-lu-dai-ni-xue-tou-dpzi-vidge/。</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建流程</title>
      <link href="/2023/06/18/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/06/18/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客搭建流程"><a href="#个人博客搭建流程" class="headerlink" title="个人博客搭建流程"></a>个人博客搭建流程</h1><p>本贴我将为大家介绍一下我个人博客搭建的流程。</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>由于个人网站大部分都是一些静态资源，如html、css、图片、markdown文件等，不需要与后端进行交互，也不需要存储一些关系复杂的数据，因此只需要实现一个大前端即可。</p><p>如果你对页面的美观布局没有太大的追求，只是在页面上写一些相对简单的内容，那完全可以自己用html写一个页面，然后部署到nginx服务器上面。但是如果你想长期维护你的网站，并且想专注于内容的创作而非技术实现，可以试着用WordPress、Jekyll、Hexo等网站构建工具。本人使用的网站构建工具是Hexo，对其他工具感兴趣的小伙伴也可以自行尝试。</p><h3 id="网站构建工具的原理"><a href="#网站构建工具的原理" class="headerlink" title="网站构建工具的原理"></a>网站构建工具的原理</h3><p>网站构建工具的原理是将一个网站的基本结构和功能封装成软件组件，用户可以通过简单的操作，使用这些组件来快速地搭建出自己所需的网站。用户可以自由选择主题、插件和小部件等组件，根据自己的需求和喜好来定制网站的外观和功能。</p><p>网站构建工具实际上是在后台自动进行代码编写和程序运行。工具会把用户在配置文件（如xml、yml等）或图形化界面上进行的操作转化为相应的HTML、CSS、JavaScript代码或是其他语言的代码，并且把这些代码嵌入到网站中。同时，网站构建工具还可以自动优化网站的响应速度和搜索引擎排名等方面的性能。</p><p>以Hexo框架为例，其使用markdown来解析文章。Hexo 内建 <a href="https://mozilla.github.io/nunjucks/">Nunjucks</a> 模板引擎，可以另外安装插件来获得 <a href="https://github.com/hexojs/hexo-renderer-ejs">EJS</a>、<a href="https://github.com/hexojs/hexo-renderer-haml">Haml</a>、<a href="https://github.com/hexojs/hexo-renderer-jade">Jade</a> 或 <a href="https://github.com/maxknee/hexo-render-pug">Pug</a> 支持。Hexo 根据模板文件的扩展名来决定所使用的模板引擎，用于在Node.js服务器端构建Web应用程序。这两个模板工具会动态地读取配置文件和对应目录文件中的内容（比如markdown、图片等），一键生成HTML、CSS和JavaScript前端代码。</p><h3 id="需要用到的技术"><a href="#需要用到的技术" class="headerlink" title="需要用到的技术"></a>需要用到的技术</h3><p>在搭建个人网站之前，要确保你已经学过git版本管理工具、了解过一些前端方面的知识。而且要在本机安装好git和nodejs。</p><h2 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h2><h3 id="1-hexo安装"><a href="#1-hexo安装" class="headerlink" title="1.hexo安装"></a>1.hexo安装</h3><p>参考这个链接：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p>其中有几个重要的命令需要记住，以后会用到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(npx) hexo clean<span class="comment"># 清理Hexo已经生成的目标文件</span></span><br><span class="line">(npx) hexo g<span class="comment"># 生成目标文件</span></span><br><span class="line">(npx) hexo s<span class="comment"># 本地启动</span></span><br><span class="line">(npx) hexo d<span class="comment"># 发布到远程服务器</span></span><br><span class="line">(npx) hexo new [page] 文件名 <span class="comment"># 发布页面/博客，不打page的话默认是发博客</span></span><br></pre></td></tr></table></figure><h3 id="2-选择主题"><a href="#2-选择主题" class="headerlink" title="2.选择主题"></a>2.选择主题</h3><p>在这个链接中找到你喜欢的主题：<a href="https://hexo.io/themes/">点击此处</a>，然后把它拉取到你的本地进行编辑。<br>本人使用的是<a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a>这个主题。主页美化的细节请小伙伴们自行参考主题对应的文档，比如我的这个主题可以在GitHub上面找到：<a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a>，不多介绍。</p><h3 id="3-评论功能"><a href="#3-评论功能" class="headerlink" title="3.评论功能"></a>3.评论功能</h3><p>传统的评论功能实现需要给后端发送post请求，然后再更新数据库或者服务端的json文件，比较麻烦。这里使用的是一个ServerLess的云服务：<a href="https://www.leancloud.cn/">leancloud</a>以及无后端评论系统<a href="https://valine.js.org/">Valine</a>。这两个服务都非常适合个人使用，直接拿来主义，非常方便。</p><h3 id="4-部署到GitHub"><a href="#4-部署到GitHub" class="headerlink" title="4.部署到GitHub"></a>4.部署到GitHub</h3><p>我参考的是这个链接：<a href="https://blog.csdn.net/sinat_37781304/article/details/82729029?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168707186516800192224761%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168707186516800192224761&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-82729029-null-null.142^v88^insert_down38v5,239^v2^insert_chatgpt&amp;utm_term=hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2&amp;spm=1018.2226.3001.4187">hexo史上最全搭建教程</a></p><p>至此，个人网站的搭建就基本完成了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LRU缓存的实现</title>
      <link href="/2023/06/17/LRU%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/06/17/LRU%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="LRU缓存的实现"><a href="#LRU缓存的实现" class="headerlink" title="LRU缓存的实现"></a>LRU缓存的实现</h1><p>面试时有可能会被问到LRU的具体实现。在 Python 语言中，有一种结合了哈希表与双向链表的数据结构 OrderedDict，只需要短短的几行代码就可以完成本题。在 Java 语言中，同样有类似的数据结构 LinkedHashMap。但这些做法都不会符合面试官的要求，因此我们需要了解LRU底层的原理。</p><p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p><pre><code>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</code></pre><p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：</p><pre><code>对于 get 操作，首先判断 key 是否存在：    如果 key 不存在，则返回 −1；    如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。对于 put 操作，首先判断 key 是否存在：    如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；    如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</code></pre><p>上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1) 时间内完成。</p><p>下面给出Java代码的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Node prev;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.key = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.value = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, Node next, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">// map存的是Node的引用，所以Node更新的时候map里面的值也会跟着更新</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Node dummyHead;</span><br><span class="line">    <span class="keyword">private</span> Node dummyTail;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Node&gt;();</span><br><span class="line">        dummyHead = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        dummyTail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        dummyHead.next = dummyTail;</span><br><span class="line">        dummyTail.prev = dummyHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">            map.put(key, addToHead(<span class="keyword">new</span> <span class="title class_">Node</span>(key, value)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">            deleteFromTail();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev = dummyHead;</span><br><span class="line">        node.next = dummyHead.next;</span><br><span class="line">        dummyHead.next.prev = node;</span><br><span class="line">        dummyHead.next = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        deleteNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteFromTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> dummyTail.prev.key;</span><br><span class="line">            deleteNode(dummyTail.prev);</span><br><span class="line">            map.remove(key);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/17/hello-world/"/>
      <url>/2023/06/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello World！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2023/06/17/test/"/>
      <url>/2023/06/17/test/</url>
      
        <content type="html"><![CDATA[<p>本帖是一个测试贴</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>archives</title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>个人简历</title>
      <link href="/cv/index.html"/>
      <url>/cv/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li>姓名：thx</li><li>手机：保密</li><li>邮箱：2508496612@qq.com</li><li>地址：天津市津南区</li></ul><h1 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h1><h2 id="天津大学（2019年-2024年）"><a href="#天津大学（2019年-2024年）" class="headerlink" title="天津大学（2019年~2024年）"></a>天津大学（2019年~2024年）</h2><ul><li>专业：计算机科学与技术</li><li>学位：本科</li><li>主修课程：程序设计原理、数据结构、算法设计与分析、离散数学、操作系统、数据库原理、计算机网络、计算机组成原理、软件工程、编译原理</li></ul><h1 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h1><h2 id="中国汽车技术研究中心-设计院-（2023年5月-至今）"><a href="#中国汽车技术研究中心-设计院-（2023年5月-至今）" class="headerlink" title="中国汽车技术研究中心 设计院 （2023年5月~至今）"></a>中国汽车技术研究中心 设计院 （2023年5月~至今）</h2><ul><li>职位：Java后端开发实习生</li><li>工作内容：数据迁移、代码重构、接口开发</li></ul><h1 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h1><h2 id="TCP在应用层的设计和实现-（2022年7月-2022年9月）"><a href="#TCP在应用层的设计和实现-（2022年7月-2022年9月）" class="headerlink" title="TCP在应用层的设计和实现 （2022年7月~2022年9月）"></a>TCP在应用层的设计和实现 （2022年7月~2022年9月）</h2><ul><li>项目描述：本项目实现了基于UDP的用户层TCP协议，完成了Socket API的实现，协议整体的设计和实现参考了RFC793文档中对TCP实现的说明。</li><li>项目亮点：<br>  在用户层模拟部分linux内核行为，如socket哈希表的维护、全连接与半连接队列、TCP报文段的处理等<br>  完成了底层协议设计，采用C语言来实现TCP的三次握手、四次挥手、流量控制和拥塞控制等功能<br>  在可靠数据传输中主要采用滑动窗口和超时重传机制来实现，并以延时发送ACK来优化传输速度<br>  在Linux环境下采用多线程编程，实现服务端和客户端之间的单工通信，峰值吞吐率可达到5Mbps，平均吞吐率在1Mbps左右，具有良好的稳定性</li></ul><h2 id="基于淘宝逆向设计的北洋商城系统-（2022年10月-2023年1月）"><a href="#基于淘宝逆向设计的北洋商城系统-（2022年10月-2023年1月）" class="headerlink" title="基于淘宝逆向设计的北洋商城系统 （2022年10月~2023年1月）"></a>基于淘宝逆向设计的北洋商城系统 （2022年10月~2023年1月）</h2><ul><li>项目描述：本项目是仿照淘宝和拼多多实现的在线商城系统，由商户后台和移动端前台两部分构成，包含用户注册、用户登录、添加商品、浏览商品、商品详情页、个人主页、余额充值、购买商品、查看订单等模块。</li><li>技术栈：Vue2、SpringBoot、LomBok、HuTool、MyBatis、MySQL、Redis</li><li>主要工作：<br>  分析各个实体的关系，完成数据库总体设计，并绘制ER图<br>  负责后端框架的搭建，完成业务层对数据库的操作，实现常用公共字段的自动填充<br>  实现用户管理、商品管理、购物车管理和订单管理相关功能的实现<br>  基于Redis对热点查询字段进行缓存，提高系统的并发能力<br>  使用Nginx作为Http服务器，部署静态资源，实现反向管理和负载均衡</li></ul><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><ul><li>编程基础：数据结构与算法、操作系统、计算机网络、面向对象编程思想、设计模式</li><li>编程语言：Java（熟练）、C/C++（熟悉）、Python（了解）、JavaScript（了解）</li><li>后端框架：Spring、Mybatis/Mybatis-plus、Spring MVC、SpringBoot、SpringCloud</li><li>前端：html、css、vue、jQuery</li><li>数据库：MySQL、Oracle</li><li>中间件：redis、nacos、rabbitmq</li><li>开发工具：IDEA、VS Code、Navicat、Postman、VMware、Xshell</li><li>虚拟机：Ubuntu、CentOS、</li><li>容器化技术：Docker</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>一起看电影吧！</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="此频道暂未开发-gt-lt"><a href="#此频道暂未开发-gt-lt" class="headerlink" title="此频道暂未开发&gt;_&lt;"></a>此频道暂未开发&gt;_&lt;</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>It&#39;s music time now!</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="下面是自己编的一些小曲，请收听-o"><a href="#下面是自己编的一些小曲，请收听-o" class="headerlink" title="下面是自己编的一些小曲，请收听^o^"></a>下面是自己编的一些小曲，请收听^o^</h1><!-- - [Song 1](my-songs/春日游.m4a)- [Song 2](my-songs/song2.mp3) --><style>  .song-item {    display: flex;    align-items: center;    margin-bottom: 10px;  }  .song-item h2 {    margin-right: 10px;    font-size: 16px;    line-height: 1;  }  .song-item audio {    height: 30px;    width: 150px;  }</style><div class="song-item">  <h2>晨曦</h2>  <audio controls>    <source src="my-songs/晨曦.m4a" type="audio/mpeg">    Your browser does not support the audio element.  </audio></div><div class="song-item">  <h2>春日游</h2>  <audio controls>    <source src="my-songs/春日游.m4a" type="audio/mpeg">    Your browser does not support the audio element.  </audio></div><div class="song-item">  <h2>今日晴空万里</h2>  <audio controls>    <source src="my-songs/今日晴空万里.m4a" type="audio/mpeg">    Your browser does not support the audio element.  </audio></div><div class="song-item">  <h2>夕阳、草房子与风车</h2>  <audio controls>    <source src="my-songs/夕阳、草房子与风车.mp3" type="audio/mpeg">    Your browser does not support the audio element.  </audio></div><div class="song-item">  <h2>湖心月纹</h2>  <audio controls>    <source src="my-songs/湖心月纹.m4a" type="audio/mpeg">    Your browser does not support the audio element.  </audio></div><script>  const audioPlayer = document.querySelector('#myAudioPlayer');  audioPlayer.addEventListener('play', () => {    console.log('音乐开始播放');  });  audioPlayer.addEventListener('pause', () => {    console.log('音乐暂停播放');  });</script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
